/*
 * This source file is part of the Argon project.
 *
 * Licensed under the Apache License v2.0
*/

from error import TypeError
from sync import NotifyQueue

let P_PENDING = 0
let P_FULFILLED = 1
let P_REJECTED = 2

pub struct Promise {
    var status
    var value
    var queue

    pub let new = (executor) => {
        if executor != nil && !callable(executor) {
            panic(TypeError::new("Promise::new argument is not a function"))
        }

        var promise = Promise!{P_PENDING, nil, NotifyQueue::new()}

        spawn promise.do(executor)

        return promise;
    }

    func do_recover() {
        var r = recover()

        if r != nil {
            self.status = P_REJECTED
            self.value = r
        }
    }

    pub func do(executor) {
        if executor == nil {
            return nil
        }

        defer self.queue.notifyall()
        defer self.do_recover()

        executor(self.resolve(), self.rejected())
    }

    func resolve(value) {
        self.status = P_FULFILLED
        self.value = value
    }

    func rejected(value) {
        self.status = P_REJECTED
        self.value = value
    }

    func set_status(status, value) {
        self.status = status
        self.value = value

        self.queue.notifyall()
    }

    func handler_recover(promise) {
        var r = recover()

        if r != nil {
            promise.rejected(r)
        }
    }

    func exec_handler(promise, handler, status) {
        defer self.handler_recover(promise)

        if self.status == P_PENDING {
            self.queue.waitnow()
        }

        if self.status != status {
            return promise.set_status(self.status, self.value)
        }

        var res = handler(self.value)

        if type(res) == Promise {
            if res.status == P_PENDING {
                res.queue.waitnow()
            }

            return promise.set_status(res.status, res.value)
        }

        promise.set_status(status, res)
    }

    pub func then(handler) {
        if !callable(handler) {
            panic(TypeError::new("Promise::then argument is not a function"))
        }

        var promise = Promise::new(nil)

        spawn self.exec_handler(promise, handler, P_FULFILLED)

        return promise
    }

    pub func catch(handler) {
        if !callable(handler) {
            panic(TypeError::new("Promise::catch argument is not a function"))
        }

        var promise = Promise::new(nil)

        spawn self.exec_handler(promise, handler, P_REJECTED)

        return promise
    }

    pub func get() {
        if self.status == P_PENDING {
            self.queue.waitnow()
        }

        return self.value, self.status == P_FULFILLED ? true : false
    }
}