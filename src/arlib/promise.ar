/*
 * This source file is part of the Argon project.
 *
 * Licensed under the Apache License v2.0
*/

from error import TypeError
from sync import NotifyQueue

let P_PENDING = 0
let P_FULFILLED = 1
let P_REJECTED = 2

let STATUS_STRING = ["Pending",
                    "Fulfilled",
                    "Rejected"]

pub struct Promise {
    var status
    var value
    var queue

    pub let new = (executor) => {
        if executor != nil && !callable(executor) {
            panic(TypeError::new("Promise::new argument is not a function"))
        }

        var promise = Promise{P_PENDING, nil, NotifyQueue::new()}

        spawn promise.do(executor)

        return promise;
    }

    pub let new_resolved = (value) => {
        return Promise{P_FULFILLED, value, nil}
    }

    pub let new_rejected = (value) => {
        return Promise{P_REJECTED, value, nil}
    }

    pub let all = (promises) => {
        if type(promises) != list && type(promises) != tuple {
            panic(TypeError::new("Promise::all argument is not a list"))
        }

        if !promises {
            return Promise::new_resolved([])
        }

        return Promise::new((f, r) => {
            var ret = []
            var status
            var value
            
            var cursor

            for cursor in promises {
                if type(cursor) == Promise {
                    value, status = cursor.get()
                    
                    if !status {
                        return r(value)
                    }

                    ret.append(value)
                    continue
                }

                ret.append(cursor)
            }

            f(ret)
        })
    }

    pub let wait = (promises) => {
        if type(promises) != list && type(promises) != tuple {
            panic(TypeError::new("Promise::wait argument is not a list"))
        }

        if !promises {
            return Promise::new_resolved([])
        }

        return Promise::new((f, r) => {
            var ret = []
            var cursor

            for cursor in promises {
                if type(cursor) == Promise {
                    cursor.get()
                }

                ret.append(cursor)
            }

            f(ret)
        })
    }

    func do_recover() {
        var r = recover()

        if r != nil {
            self.status = P_REJECTED
            self.value = r
        }
    }

    pub func do(executor) {
        if executor == nil {
            return nil
        }

        defer self.queue.notifyall()
        defer self.do_recover()

        executor(self.resolve(), self.rejected())
    }

    func resolve(value) {
        self.status = P_FULFILLED
        self.value = value
    }

    func rejected(value) {
        self.status = P_REJECTED
        self.value = value
    }

    func set_status(status, value) {
        self.status = status
        self.value = value

        self.queue.notifyall()
    }

    func handler_recover(promise) {
        var r = recover()

        if r != nil {
            promise.rejected(r)
        }
    }

    func exec_handler(promise, handler, status) {
        defer self.handler_recover(promise)

        if self.status == P_PENDING {
            self.queue.waitnow()
        }

        if self.status != status {
            return promise.set_status(self.status, self.value)
        }

        var res = handler(self.value)

        if type(res) == Promise {
            if res.status == P_PENDING {
                res.queue.waitnow()
            }

            return promise.set_status(res.status, res.value)
        }

        promise.set_status(status, res)
    }

    pub func then(handler) {
        if !callable(handler) {
            panic(TypeError::new("Promise::then argument is not a function"))
        }

        var promise = Promise::new(nil)

        spawn self.exec_handler(promise, handler, P_FULFILLED)

        return promise
    }

    pub func catch(handler) {
        if !callable(handler) {
            panic(TypeError::new("Promise::catch argument is not a function"))
        }

        var promise = Promise::new(nil)

        spawn self.exec_handler(promise, handler, P_REJECTED)

        return promise
    }

    pub func get() {
        if self.status == P_PENDING {
            self.queue.waitnow()
        }

        return self.value, self.status == P_FULFILLED ? true : false
    }

    pub func __str() {
        return "<Promise: status: %s, value: %s>" % (STATUS_STRING[self.status], self.value)
    }
}