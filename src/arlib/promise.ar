/*
 * This source file is part of the Argon project.
 *
 * Licensed under the Apache License v2.0
*/

from sync import NotifyQueue

let P_PENDING = 0
let P_FULFILLED = 1
let P_REJECTED = 2

pub struct Promise {
    var status = P_PENDING
    var value
    var queue

    func resolve(value) {
        self.value = value
        self.status = P_FULFILLED
    }

    func rejected(value) {
        self.value = value
        self.status = P_REJECTED
    }

    func do_recover() {
        var r = recover()

        if r != nil {
            self.status = P_REJECTED
            self.value = r
        }
    }

    pub func do(executor) {
        defer self.queue.notifyall()
        defer self.do_recover()

        executor(Promise::resolve(self), Promise::rejected(self))
    }

    pub let new = (executor) => {
        var t = Promise!{P_PENDING, nil, NotifyQueue::new()}

        spawn t.do(executor)

        return t
    }

    func protected_handler(handler) {
        defer () => {
            var r = recover()

            if r != nil {
                returns(Promise!{P_REJECTED, r})
            }
        }()

        return handler(self.value)
    }

    func exec_handler(status, handler) {
        var res

        if self.status == P_PENDING {
            self.queue.wait(self.queue.getticket())
        }

        if self.status == status {
            if handler != nil {
                res = self.protected_handler(handler)
            }

            if type(res) == Promise {
                return res
            }

            return Promise!{status, res}
        }

        return self
    }

    pub func then(fulfilled) {
        return self.exec_handler(P_FULFILLED, fulfilled)
    }

    pub func catch(rejected) {
        return self.exec_handler(P_REJECTED, rejected)
    }
}
