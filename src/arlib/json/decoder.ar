/*
 * This source file is part of the Argon project.
 *
 * Licensed under the Apache License v2.0
 *
 * JSON Encoder/Decoder (RFC 8259)
*/

import regex
from json::scanner import Scanner, ScannerCallback, DecodeError, skip_spaces

let STRING_RE = regex::compile(r#".*?[^\\]""#, regex::MODE_ECMASCRIPT | regex::OPTIMIZE)

pub struct Decoder impl ScannerCallback {
    pub func parse_array(scanner, buffer, index) {
        var length = len(buffer)
        var items = []
        var item

        index = skip_spaces(buffer, index)
        if buffer[index] == ']' {
            return items, index + 1
        }

        loop index < length {
            item, index = scanner.scan(buffer, index)

            items.append(item)

            index = skip_spaces(buffer, index)
            if buffer[index] == ']' {
                break
            }

            if buffer[index] != ',' {
                panic(DecodeError::new("expecting ',' delimiter", buffer, index))
            }

            index = index + 1
        }

        return items, index + 1
    }

    pub func parse_object(scanner, buffer, index) {
        var length = len(buffer)
        var obj = {}
        var key
        var value

        index = skip_spaces(buffer, index)
        if buffer[index] == '}' {
            return obj, index + 1
        }

        loop index < length {
            key, value, index = self.keypair(scanner, buffer, index)

            obj[key] = value

            index = skip_spaces(buffer, index)
            if buffer[index] == '}' {
                break
            }

            if buffer[index] != ',' {
                panic(DecodeError::new("expecting ',' delimiter", buffer, index))
            }

            index = index + 1
        }

        return obj, index + 1
    }

    pub func keypair(scanner, buffer, index) {
        var length = len(buffer)
        var key
        var value

        index = skip_spaces(buffer, index)
        if buffer[index] != '"' {
            panic(DecodeError::new("expecting property name enclosed in double quotes", buffer, index))
        }

        key, index = self.parse_string(scanner, buffer, index + 1)

        index = skip_spaces(buffer, index)
        if buffer[index] != ':' {
            panic(DecodeError::new("expecting ':' delimiter", buffer, index))
        }

        index = index + 1 # skip :

        value, index = scanner.scan(buffer, index)

        return key, value, index
    }

    pub func parse_string(scanner, buffer, index) {
        if buffer[index] == '"' {
            return "", index + 1
        }

        var view = buffer[index:]

        var match = STRING_RE.search(view)
        if !match {
            panic(DecodeError::new("unterminated string", buffer, index))
        }

        return string::unescape(view[:match[0].end - 1]), index + match[0].end
    }
}
