/*
 * This source file is part of the Argon project.
 *
 * Licensed under the Apache License v2.0
 *
 * JSON Encoder/Decoder (RFC 8259)
*/

import regex
import math
from error import NotImplemented

let NUMBER_RE = regex::compile("(-?(?:0|[1-9]\d*))(\.\d+)?([eE][-+]?\d+)?", regex::MODE_ECMASCRIPT | regex::OPTIMIZE)

pub trait ScannerCallback {
    pub func parse_array(scanner, buffer, index)
    pub func parse_object(scanner, buffer, index)
    pub func parse_string(scanner, buffer, index)
}

pub struct DecodeError {
    pub var msg
    pub var buf
    pub var index

    pub let new = (msg, buffer, index) => {
        return DecodeError{msg, buffer, index}
    }

    pub func __str() {
        return "%s (index: %d):" % (self.msg, self.index)
    }
}

pub func skip_spaces(buffer, index) {
    var c = buffer[index]

    loop c == '\t' || c == '\n' || c == '\r' || c == ' ' {
        index += 1 # skip spaces, tabs and new-lines
        c = buffer[index]
    }

    return index
}

pub struct Scanner {
    var callbacks

    pub let new = (callback) => {
        if !isimpl(callback, ScannerCallback) {
            panic(NotImplemented::new("'%s' not implement %s" % (type(callback), ScannerCallback)))
        }

        return Scanner{callback}
    }

    func is_number(buffer, index) {
        var view = buffer[index:]
        var match
        var int
        var frac
        var exp

        match = NUMBER_RE.search(view)
        if !match {
            panic(DecodeError::new("number", buffer, index))
        }

        int, frac, exp = match
        if frac || exp {
            return index + exp.end, view[:exp.end], true
        }

        return index + int.end, view[:int.end], false
    }

    pub func scan(buffer, index) {
        var num_str
        var float

        index = skip_spaces(buffer, index)

        switch buffer[index] {
            case '"':
                return self.callbacks.parse_string(self, buffer, index + 1)
            case '[':
                return self.callbacks.parse_array(self, buffer, index +1)
            case '{':
                return self.callbacks.parse_object(self, buffer, index + 1)
            case 'n':
                if buffer[index:index + 4] == b"null" {
                    return nil, index + 4
                }
            case 't':
                if buffer[index:index + 4] == b"true" {
                    return true, index + 4
                }
            case 'f':
                if buffer[index:index + 5] == b"false" {
                    return false, index + 5
                }
            case 'N':
                if buffer[index:index + 3] == b"NaN" {
                    return math::nan, index + 3
                }
            case 'I':
                if buffer[index:index + 8] == b"Infinity" {
                    return math::inf, index + 8
                }
            case '-':
                if buffer[index:index + 9] == b"-Infinity" {
                    return -math::inf, index + 9
                }
        }

        index, num_str, float = self.is_number(buffer, index)

        if !float {
            return integer::new(num_str), index
        }

        return decimal::new(num_str), index
    }
}
