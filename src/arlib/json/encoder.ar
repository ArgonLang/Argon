/*
 * This source file is part of the Argon project.
 *
 * Licensed under the Apache License v2.0
 *
 * JSON Encoder/Decoder (RFC 8259)
*/

import math
from error import NotImplemented, TypeError, ValueError

pub trait JSONEncoder {
	pub func encode(encoder, obj, buffer)
}

pub struct Encoder {
    pub var separators = (b", ", b": ")
    pub var newlines = true
    pub var indent = 0

	pub let new = (separators, nl, indent) => {
		if type(separators) != tuple {
			panic TypeError::new("separators must be a tuple not '%s'" % type(separators))
		}

		if len(separators) != 2 {
			panic ValueError::new("separators must have length of 2")
		}

		if type(indent) != integer {
			panic TypeError::new("indent must be a integer not '%s'" % type(indent))
		}

		return Encoder{separators, nl, indent}
	}

	pub func encode(obj, buffer) {
		if obj == nil {
			buffer += b"null"
			return buffer
		}

		switch type(obj) {
		case bool:
		    buffer += obj ? b"true" : b"false"
		    return buffer
		case map:
			return self.enc_map(obj, buffer)
		case list; tuple:
			return self.enc_array(obj, buffer)
		case string:
			buffer += b"\"%s\"" % obj
			return buffer
		case decimal:
			if obj == math.nan {
				buffer += b"NaN"
				return buffer
			} elif obj == math.inf {
				buffer += b"Infinity"
				return buffer
			} elif obj == -math.inf {
				buffer += b"-Infinity"
				return buffer
			}
			
			buffer += b"%f" % obj
			return buffer
		case integer:
			buffer += b"%i" % obj
			return buffer
		}

		if !isimpl(obj, JSONEncoder) {
			panic NotImplemented::new("object of type '%s' is not JSON serializable" % type(obj))
		}

		return obj.encode(self, obj, buffer)
	}

	func enc_map(obj, buffer) {
		var key
		var value
		var sep
		var keysep
		var many = false

		if !obj {
			buffer += b"{}"
			return buffer
		}

		sep, keysep = self.separators

		buffer += b"{" + (self.newlines ? b"\n" : b"")

		self.indent++

		for key, value in obj {
			if many {
				buffer += sep + (self.newlines ? b"\n" : b"")
			}

			if self.newlines {
				buffer += b"\t" * self.indent
			}

			if type(key) != string {
				panic ValueError::new("expected string as key, not %s" % type(key))
			}

			buffer += b"\"%s\"%s" % (key, keysep)
			self.encode(value, buffer)

			many = true
		}

		self.indent--
		
		buffer += self.newlines ? b"\n%s}" % (b"\t" * self.indent) : b"}"

		return buffer
	}

	func enc_array(obj, buffer) {
		var sep = self.separators[0]
		var many = false
		var value

		if !obj {
			buffer += b"[]"
			return buffer
		}

		buffer += b"[" + (self.newlines ? b"\n" : b"")

		self.indent++

		for value in obj {
			if many {
				buffer += sep + (self.newlines ? b"\n" : b"")
			}

			if self.newlines {
				buffer += b"\t" * self.indent
			}

			self.encode(value, buffer)
			many = true
		}

		self.indent--

		buffer += self.newlines ? b"\n%s]" % (b"\t" * self.indent) : b"]"

		return buffer
	}
}
